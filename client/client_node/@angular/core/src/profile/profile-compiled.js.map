{"version":3,"sources":["profile.js"],"names":[],"mappings":"AAAA;;;;;;;AAOA;;AACA,IAAI,aAAa,QAAQ,YAAR,CAAjB;AACA;AACA;;;AAGA,QAAQ,UAAR,GAAqB,WAAW,SAAX,EAArB;AACA,SAAS,SAAT,CAAmB,IAAnB,EAAyB,IAAzB,EAA+B;AAC3B,SAAO,IAAP;AACH;AACD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA8BA,QAAQ,cAAR,GAAyB,QAAQ,UAAR,GAAqB,WAAW,WAAhC,GAA8C,UAAU,SAAV,EAAqB,KAArB,EAA4B;AAAE,SAAO,SAAP;AAAmB,CAAxH;AACA;;;;;;;;;AASA,QAAQ,QAAR,GAAmB,QAAQ,UAAR,GAAqB,WAAW,KAAhC,GAAwC,UAAU,CAAV,EAAa,CAAb,EAAgB;AAAE,SAAO,CAAP;AAAW,CAAxF;AACA;;;;;;;;;;;;;AAaA,QAAQ,iBAAR,GAA4B,QAAQ,UAAR,GAAqB,WAAW,cAAhC,GAAiD,UAAU,SAAV,EAAqB,MAArB,EAA6B;AAAE,SAAO,IAAP;AAAc,CAA1H;AACA;;;;;;AAMA,QAAQ,eAAR,GAA0B,QAAQ,UAAR,GAAqB,WAAW,YAAhC,GAA+C,UAAU,CAAV,EAAa;AAAE,SAAO,IAAP;AAAc,CAAtG;AACA","file":"profile-compiled.js","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\"use strict\";\nvar wtf_impl_1 = require('./wtf_impl');\n// Change exports to const once https://github.com/angular/ts2dart/issues/150\n/**\n * True if WTF is enabled.\n */\nexports.wtfEnabled = wtf_impl_1.detectWTF();\nfunction noopScope(arg0, arg1) {\n    return null;\n}\n/**\n * Create trace scope.\n *\n * Scopes must be strictly nested and are analogous to stack frames, but\n * do not have to follow the stack frames. Instead it is recommended that they follow logical\n * nesting. You may want to use\n * [Event\n * Signatures](http://google.github.io/tracing-framework/instrumenting-code.html#custom-events)\n * as they are defined in WTF.\n *\n * Used to mark scope entry. The return value is used to leave the scope.\n *\n *     var myScope = wtfCreateScope('MyClass#myMethod(ascii someVal)');\n *\n *     someMethod() {\n *        var s = myScope('Foo'); // 'Foo' gets stored in tracing UI\n *        // DO SOME WORK HERE\n *        return wtfLeave(s, 123); // Return value 123\n *     }\n *\n * Note, adding try-finally block around the work to ensure that `wtfLeave` gets called can\n * negatively impact the performance of your application. For this reason we recommend that\n * you don't add them to ensure that `wtfLeave` gets called. In production `wtfLeave` is a noop and\n * so try-finally block has no value. When debugging perf issues, skipping `wtfLeave`, do to\n * exception, will produce incorrect trace, but presence of exception signifies logic error which\n * needs to be fixed before the app should be profiled. Add try-finally only when you expect that\n * an exception is expected during normal execution while profiling.\n *\n * @experimental\n */\nexports.wtfCreateScope = exports.wtfEnabled ? wtf_impl_1.createScope : function (signature, flags) { return noopScope; };\n/**\n * Used to mark end of Scope.\n *\n * - `scope` to end.\n * - `returnValue` (optional) to be passed to the WTF.\n *\n * Returns the `returnValue for easy chaining.\n * @experimental\n */\nexports.wtfLeave = exports.wtfEnabled ? wtf_impl_1.leave : function (s, r) { return r; };\n/**\n * Used to mark Async start. Async are similar to scope but they don't have to be strictly nested.\n * The return value is used in the call to [endAsync]. Async ranges only work if WTF has been\n * enabled.\n *\n *     someMethod() {\n *        var s = wtfStartTimeRange('HTTP:GET', 'some.url');\n *        var future = new Future.delay(5).then((_) {\n *          wtfEndTimeRange(s);\n *        });\n *     }\n * @experimental\n */\nexports.wtfStartTimeRange = exports.wtfEnabled ? wtf_impl_1.startTimeRange : function (rangeType, action) { return null; };\n/**\n * Ends a async time range operation.\n * [range] is the return value from [wtfStartTimeRange] Async ranges only work if WTF has been\n * enabled.\n * @experimental\n */\nexports.wtfEndTimeRange = exports.wtfEnabled ? wtf_impl_1.endTimeRange : function (r) { return null; };\n//# sourceMappingURL=profile.js.map"]}