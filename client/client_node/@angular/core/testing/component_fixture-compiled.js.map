{"version":3,"sources":["component_fixture.js"],"names":[],"mappings":"AAAA;;;;;;;AAOA;;AACA,IAAI,UAAU,QAAQ,UAAR,CAAd;AACA,IAAI,UAAU,QAAQ,qBAAR,CAAd;AACA,IAAI,eAAe,QAAQ,0BAAR,CAAnB;AACA,IAAI,SAAS,QAAQ,oBAAR,CAAb;AACA;;;;;AAKA,IAAI,mBAAoB,YAAY;AAChC,aAAS,gBAAT,CAA0B,YAA1B,EAAwC,MAAxC,EAAgD,UAAhD,EAA4D;AACxD,YAAI,QAAQ,IAAZ;AACA,aAAK,SAAL,GAAiB,IAAjB;AACA,aAAK,UAAL,GAAkB,IAAlB;AACA,aAAK,uBAAL,GAA+B,IAA/B;AACA,aAAK,qBAAL,GAA6B,IAA7B;AACA,aAAK,6BAAL,GAAqC,IAArC;AACA,aAAK,oBAAL,GAA4B,IAA5B;AACA,aAAK,iBAAL,GAAyB,aAAa,iBAAtC;AACA,aAAK,UAAL,GAAkB,aAAa,QAA/B;AACA,aAAK,YAAL,GAAoB,QAAQ,YAAR,CAAqB,KAAK,UAAL,CAAgB,aAArC,CAApB;AACA,aAAK,iBAAL,GAAyB,aAAa,QAAtC;AACA,aAAK,aAAL,GAAqB,KAAK,UAAL,CAAgB,aAArC;AACA,aAAK,YAAL,GAAoB,YAApB;AACA,aAAK,MAAL,GAAc,MAAd;AACA,aAAK,WAAL,GAAmB,UAAnB;AACA,YAAI,UAAU,IAAd,EAAoB;AAChB,iBAAK,uBAAL,GACI,QAAQ,iBAAR,CAA0B,SAA1B,CAAoC,OAAO,UAA3C,EAAuD,UAAU,CAAV,EAAa;AAAE,sBAAM,SAAN,GAAkB,KAAlB;AAA0B,aAAhG,CADJ;AAEA,iBAAK,6BAAL,GACI,QAAQ,iBAAR,CAA0B,SAA1B,CAAoC,OAAO,gBAA3C,EAA6D,UAAU,CAAV,EAAa;AACtE,oBAAI,MAAM,WAAV,EAAuB;AACnB;AACA;AACA,0BAAM,aAAN,CAAoB,IAApB;AACH;AACJ,aAND,CADJ;AAQA,iBAAK,qBAAL,GAA6B,QAAQ,iBAAR,CAA0B,SAA1B,CAAoC,OAAO,QAA3C,EAAqD,UAAU,CAAV,EAAa;AAC3F,sBAAM,SAAN,GAAkB,IAAlB;AACA;AACA;AACA,uBAAO,iBAAP,CAAyB,YAAY;AACjC,wBAAI,CAAC,MAAM,MAAN,CAAa,oBAAlB,EAAwC;AACpC,4BAAI,MAAM,UAAN,IAAoB,IAAxB,EAA8B;AAC1B,kCAAM,UAAN,CAAiB,OAAjB,CAAyB,IAAzB;AACA,kCAAM,UAAN,GAAmB,IAAnB;AACH;AACJ;AACJ,iBAPD;AAQH,aAZ4B,CAA7B;AAaA,iBAAK,oBAAL,GAA4B,QAAQ,iBAAR,CAA0B,SAA1B,CAAoC,OAAO,OAA3C,EAAoD,UAAU,KAAV,EAAiB;AAAE,sBAAM,MAAM,KAAZ;AAAoB,aAA3F,CAA5B;AACH;AACJ;AACD,qBAAiB,SAAjB,CAA2B,KAA3B,GAAmC,UAAU,cAAV,EAA0B;AACzD,aAAK,iBAAL,CAAuB,aAAvB;AACA,YAAI,cAAJ,EAAoB;AAChB,iBAAK,cAAL;AACH;AACJ,KALD;AAMA;;;AAGA,qBAAiB,SAAjB,CAA2B,aAA3B,GAA2C,UAAU,cAAV,EAA0B;AACjE,YAAI,QAAQ,IAAZ;AACA,YAAI,mBAAmB,KAAK,CAA5B,EAA+B;AAAE,6BAAiB,IAAjB;AAAwB;AACzD,YAAI,KAAK,MAAL,IAAe,IAAnB,EAAyB;AACrB;AACA;AACA,iBAAK,MAAL,CAAY,GAAZ,CAAgB,YAAY;AAAE,sBAAM,KAAN,CAAY,cAAZ;AAA8B,aAA5D;AACH,SAJD,MAKK;AACD;AACA,iBAAK,KAAL,CAAW,cAAX;AACH;AACJ,KAZD;AAaA;;;AAGA,qBAAiB,SAAjB,CAA2B,cAA3B,GAA4C,YAAY;AAAE,aAAK,iBAAL,CAAuB,cAAvB;AAA0C,KAApG;AACA;;;;;AAKA,qBAAiB,SAAjB,CAA2B,iBAA3B,GAA+C,UAAU,UAAV,EAAsB;AACjE,YAAI,eAAe,KAAK,CAAxB,EAA2B;AAAE,yBAAa,IAAb;AAAoB;AACjD,YAAI,KAAK,MAAL,IAAe,IAAnB,EAAyB;AACrB,kBAAM,IAAI,aAAa,aAAjB,CAA+B,oEAA/B,CAAN;AACH;AACD,aAAK,WAAL,GAAmB,UAAnB;AACA,aAAK,aAAL;AACH,KAPD;AAQA;;;;AAIA,qBAAiB,SAAjB,CAA2B,QAA3B,GAAsC,YAAY;AAAE,eAAO,KAAK,SAAL,IAAkB,CAAC,KAAK,MAAL,CAAY,oBAAtC;AAA6D,KAAjH;AACA;;;;;;AAMA,qBAAiB,SAAjB,CAA2B,UAA3B,GAAwC,YAAY;AAChD,YAAI,KAAK,QAAL,EAAJ,EAAqB;AACjB,mBAAO,QAAQ,cAAR,CAAuB,OAAvB,CAA+B,KAA/B,CAAP;AACH,SAFD,MAGK,IAAI,KAAK,UAAL,KAAoB,IAAxB,EAA8B;AAC/B,mBAAO,KAAK,UAAL,CAAgB,OAAvB;AACH,SAFI,MAGA;AACD,iBAAK,UAAL,GAAkB,IAAI,QAAQ,gBAAZ,EAAlB;AACA,mBAAO,KAAK,UAAL,CAAgB,OAAvB;AACH;AACJ,KAXD;AAYA;;;AAGA,qBAAiB,SAAjB,CAA2B,OAA3B,GAAqC,YAAY;AAC7C,aAAK,YAAL,CAAkB,OAAlB;AACA,YAAI,KAAK,uBAAL,IAAgC,IAApC,EAA0C;AACtC,oBAAQ,iBAAR,CAA0B,OAA1B,CAAkC,KAAK,uBAAvC;AACA,iBAAK,uBAAL,GAA+B,IAA/B;AACH;AACD,YAAI,KAAK,qBAAL,IAA8B,IAAlC,EAAwC;AACpC,oBAAQ,iBAAR,CAA0B,OAA1B,CAAkC,KAAK,qBAAvC;AACA,iBAAK,qBAAL,GAA6B,IAA7B;AACH;AACD,YAAI,KAAK,6BAAL,IAAsC,IAA1C,EAAgD;AAC5C,oBAAQ,iBAAR,CAA0B,OAA1B,CAAkC,KAAK,6BAAvC;AACA,iBAAK,6BAAL,GAAqC,IAArC;AACH;AACD,YAAI,KAAK,oBAAL,IAA6B,IAAjC,EAAuC;AACnC,oBAAQ,iBAAR,CAA0B,OAA1B,CAAkC,KAAK,oBAAvC;AACA,iBAAK,oBAAL,GAA4B,IAA5B;AACH;AACJ,KAlBD;AAmBA,WAAO,gBAAP;AACH,CAjIuB,EAAxB;AAkIA,QAAQ,gBAAR,GAA2B,gBAA3B;AACA","file":"component_fixture-compiled.js","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\"use strict\";\nvar index_1 = require('../index');\nvar async_1 = require('../src/facade/async');\nvar exceptions_1 = require('../src/facade/exceptions');\nvar lang_1 = require('../src/facade/lang');\n/**\n * Fixture for debugging and testing a component.\n *\n * @stable\n */\nvar ComponentFixture = (function () {\n    function ComponentFixture(componentRef, ngZone, autoDetect) {\n        var _this = this;\n        this._isStable = true;\n        this._completer = null;\n        this._onUnstableSubscription = null;\n        this._onStableSubscription = null;\n        this._onMicrotaskEmptySubscription = null;\n        this._onErrorSubscription = null;\n        this.changeDetectorRef = componentRef.changeDetectorRef;\n        this.elementRef = componentRef.location;\n        this.debugElement = index_1.getDebugNode(this.elementRef.nativeElement);\n        this.componentInstance = componentRef.instance;\n        this.nativeElement = this.elementRef.nativeElement;\n        this.componentRef = componentRef;\n        this.ngZone = ngZone;\n        this._autoDetect = autoDetect;\n        if (ngZone != null) {\n            this._onUnstableSubscription =\n                async_1.ObservableWrapper.subscribe(ngZone.onUnstable, function (_) { _this._isStable = false; });\n            this._onMicrotaskEmptySubscription =\n                async_1.ObservableWrapper.subscribe(ngZone.onMicrotaskEmpty, function (_) {\n                    if (_this._autoDetect) {\n                        // Do a change detection run with checkNoChanges set to true to check\n                        // there are no changes on the second run.\n                        _this.detectChanges(true);\n                    }\n                });\n            this._onStableSubscription = async_1.ObservableWrapper.subscribe(ngZone.onStable, function (_) {\n                _this._isStable = true;\n                // Check whether there are no pending macrotasks in a microtask so that ngZone gets a chance\n                // to update the state of pending macrotasks.\n                lang_1.scheduleMicroTask(function () {\n                    if (!_this.ngZone.hasPendingMacrotasks) {\n                        if (_this._completer != null) {\n                            _this._completer.resolve(true);\n                            _this._completer = null;\n                        }\n                    }\n                });\n            });\n            this._onErrorSubscription = async_1.ObservableWrapper.subscribe(ngZone.onError, function (error) { throw error.error; });\n        }\n    }\n    ComponentFixture.prototype._tick = function (checkNoChanges) {\n        this.changeDetectorRef.detectChanges();\n        if (checkNoChanges) {\n            this.checkNoChanges();\n        }\n    };\n    /**\n     * Trigger a change detection cycle for the component.\n     */\n    ComponentFixture.prototype.detectChanges = function (checkNoChanges) {\n        var _this = this;\n        if (checkNoChanges === void 0) { checkNoChanges = true; }\n        if (this.ngZone != null) {\n            // Run the change detection inside the NgZone so that any async tasks as part of the change\n            // detection are captured by the zone and can be waited for in isStable.\n            this.ngZone.run(function () { _this._tick(checkNoChanges); });\n        }\n        else {\n            // Running without zone. Just do the change detection.\n            this._tick(checkNoChanges);\n        }\n    };\n    /**\n     * Do a change detection run to make sure there were no changes.\n     */\n    ComponentFixture.prototype.checkNoChanges = function () { this.changeDetectorRef.checkNoChanges(); };\n    /**\n     * Set whether the fixture should autodetect changes.\n     *\n     * Also runs detectChanges once so that any existing change is detected.\n     */\n    ComponentFixture.prototype.autoDetectChanges = function (autoDetect) {\n        if (autoDetect === void 0) { autoDetect = true; }\n        if (this.ngZone == null) {\n            throw new exceptions_1.BaseException('Cannot call autoDetectChanges when ComponentFixtureNoNgZone is set');\n        }\n        this._autoDetect = autoDetect;\n        this.detectChanges();\n    };\n    /**\n     * Return whether the fixture is currently stable or has async tasks that have not been completed\n     * yet.\n     */\n    ComponentFixture.prototype.isStable = function () { return this._isStable && !this.ngZone.hasPendingMacrotasks; };\n    /**\n     * Get a promise that resolves when the fixture is stable.\n     *\n     * This can be used to resume testing after events have triggered asynchronous activity or\n     * asynchronous change detection.\n     */\n    ComponentFixture.prototype.whenStable = function () {\n        if (this.isStable()) {\n            return async_1.PromiseWrapper.resolve(false);\n        }\n        else if (this._completer !== null) {\n            return this._completer.promise;\n        }\n        else {\n            this._completer = new async_1.PromiseCompleter();\n            return this._completer.promise;\n        }\n    };\n    /**\n     * Trigger component destruction.\n     */\n    ComponentFixture.prototype.destroy = function () {\n        this.componentRef.destroy();\n        if (this._onUnstableSubscription != null) {\n            async_1.ObservableWrapper.dispose(this._onUnstableSubscription);\n            this._onUnstableSubscription = null;\n        }\n        if (this._onStableSubscription != null) {\n            async_1.ObservableWrapper.dispose(this._onStableSubscription);\n            this._onStableSubscription = null;\n        }\n        if (this._onMicrotaskEmptySubscription != null) {\n            async_1.ObservableWrapper.dispose(this._onMicrotaskEmptySubscription);\n            this._onMicrotaskEmptySubscription = null;\n        }\n        if (this._onErrorSubscription != null) {\n            async_1.ObservableWrapper.dispose(this._onErrorSubscription);\n            this._onErrorSubscription = null;\n        }\n    };\n    return ComponentFixture;\n}());\nexports.ComponentFixture = ComponentFixture;\n//# sourceMappingURL=component_fixture.js.map"]}