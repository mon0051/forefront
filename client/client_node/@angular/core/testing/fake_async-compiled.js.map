{"version":3,"sources":["fake_async.js"],"names":[],"mappings":"AAAA;;;;;;;AAOA;;AACA,IAAI,UAAU,QAAQ,UAAR,CAAd;AACA,IAAI,6BAA6B,KAAK,uBAAL,CAAjC;AACA;;;;;;;;;;;;;;;;;;AAkBA,SAAS,SAAT,CAAmB,EAAnB,EAAuB;AACnB,QAAI,KAAK,OAAL,CAAa,GAAb,CAAiB,uBAAjB,KAA6C,IAAjD,EAAuD;AACnD,cAAM,IAAI,QAAQ,aAAZ,CAA0B,qCAA1B,CAAN;AACH;AACD,QAAI,wBAAwB,IAAI,0BAAJ,EAA5B;AACA,QAAI,gBAAgB,KAAK,OAAL,CAAa,IAAb,CAAkB,qBAAlB,CAApB;AACA,WAAO,YAAY;AACf,YAAI,OAAO,EAAX,CADe,CACA;AACf,aAAK,IAAI,KAAK,CAAd,EAAiB,KAAK,UAAU,MAAhC,EAAwC,IAAxC,EAA8C;AAC1C,iBAAK,KAAK,CAAV,IAAe,UAAU,EAAV,CAAf;AACH;AACD,YAAI,MAAM,cAAc,GAAd,CAAkB,YAAY;AACpC,gBAAI,MAAM,GAAG,KAAH,CAAS,KAAK,CAAd,EAAiB,IAAjB,CAAV;AACA;AACA,mBAAO,GAAP;AACH,SAJS,CAAV;AAKA,YAAI,sBAAsB,qBAAtB,CAA4C,MAA5C,GAAqD,CAAzD,EAA4D;AACxD,kBAAM,IAAI,QAAQ,aAAZ,CAA2B,sBAAsB,qBAAtB,CAA4C,MAA5C,GAAqD,GAAtD,GAC5B,uCADE,CAAN;AAEH;AACD,YAAI,sBAAsB,aAAtB,CAAoC,MAApC,GAA6C,CAAjD,EAAoD;AAChD,kBAAM,IAAI,QAAQ,aAAZ,CAA0B,sBAAsB,aAAtB,CAAoC,MAApC,GAA6C,+BAAvE,CAAN;AACH;AACD,eAAO,GAAP;AACH,KAlBD;AAmBH;AACD,QAAQ,SAAR,GAAoB,SAApB;AACA,SAAS,qBAAT,GAAiC;AAC7B,QAAI,WAAW,KAAK,OAAL,CAAa,GAAb,CAAiB,uBAAjB,CAAf;AACA,QAAI,YAAY,IAAhB,EAAsB;AAClB,cAAM,IAAI,KAAJ,CAAU,wEAAV,CAAN;AACH;AACD,WAAO,QAAP;AACH;AACD;;;;;;;;;;;;AAYA,SAAS,IAAT,CAAc,MAAd,EAAsB;AAClB,QAAI,WAAW,KAAK,CAApB,EAAuB;AAAE,iBAAS,CAAT;AAAa;AACtC,4BAAwB,IAAxB,CAA6B,MAA7B;AACH;AACD,QAAQ,IAAR,GAAe,IAAf;AACA;;;;;AAKA,SAAS,oBAAT,GAAgC;AAC5B,QAAI,WAAW,uBAAf;AACA,QAAI,gBAAgB,SAAS,qBAA7B;AACA,aAAS,qBAAT,CAA+B,MAA/B,GAAwC,CAAxC;AACH;AACD,QAAQ,oBAAR,GAA+B,oBAA/B;AACA;;;;;AAKA,SAAS,eAAT,GAA2B;AACvB,4BAAwB,eAAxB;AACH;AACD,QAAQ,eAAR,GAA0B,eAA1B;AACA","file":"fake_async-compiled.js","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\"use strict\";\nvar index_1 = require('../index');\nvar _FakeAsyncTestZoneSpecType = Zone['FakeAsyncTestZoneSpec'];\n/**\n * Wraps a function to be executed in the fakeAsync zone:\n * - microtasks are manually executed by calling `flushMicrotasks()`,\n * - timers are synchronous, `tick()` simulates the asynchronous passage of time.\n *\n * If there are any pending timers at the end of the function, an exception will be thrown.\n *\n * Can be used to wrap inject() calls.\n *\n * ## Example\n *\n * {@example testing/ts/fake_async.ts region='basic'}\n *\n * @param fn\n * @returns {Function} The function wrapped to be executed in the fakeAsync zone\n *\n * @experimental\n */\nfunction fakeAsync(fn) {\n    if (Zone.current.get('FakeAsyncTestZoneSpec') != null) {\n        throw new index_1.BaseException('fakeAsync() calls can not be nested');\n    }\n    var fakeAsyncTestZoneSpec = new _FakeAsyncTestZoneSpecType();\n    var fakeAsyncZone = Zone.current.fork(fakeAsyncTestZoneSpec);\n    return function () {\n        var args = []; /** TODO #9100 */\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i - 0] = arguments[_i];\n        }\n        var res = fakeAsyncZone.run(function () {\n            var res = fn.apply(void 0, args);\n            flushMicrotasks();\n            return res;\n        });\n        if (fakeAsyncTestZoneSpec.pendingPeriodicTimers.length > 0) {\n            throw new index_1.BaseException((fakeAsyncTestZoneSpec.pendingPeriodicTimers.length + \" \") +\n                \"periodic timer(s) still in the queue.\");\n        }\n        if (fakeAsyncTestZoneSpec.pendingTimers.length > 0) {\n            throw new index_1.BaseException(fakeAsyncTestZoneSpec.pendingTimers.length + \" timer(s) still in the queue.\");\n        }\n        return res;\n    };\n}\nexports.fakeAsync = fakeAsync;\nfunction _getFakeAsyncZoneSpec() {\n    var zoneSpec = Zone.current.get('FakeAsyncTestZoneSpec');\n    if (zoneSpec == null) {\n        throw new Error('The code should be running in the fakeAsync zone to call this function');\n    }\n    return zoneSpec;\n}\n/**\n * Simulates the asynchronous passage of time for the timers in the fakeAsync zone.\n *\n * The microtasks queue is drained at the very start of this function and after any timer callback\n * has been executed.\n *\n * ## Example\n *\n * {@example testing/ts/fake_async.ts region='basic'}\n *\n * @experimental\n */\nfunction tick(millis) {\n    if (millis === void 0) { millis = 0; }\n    _getFakeAsyncZoneSpec().tick(millis);\n}\nexports.tick = tick;\n/**\n * Discard all remaining periodic tasks.\n *\n * @experimental\n */\nfunction discardPeriodicTasks() {\n    var zoneSpec = _getFakeAsyncZoneSpec();\n    var pendingTimers = zoneSpec.pendingPeriodicTimers;\n    zoneSpec.pendingPeriodicTimers.length = 0;\n}\nexports.discardPeriodicTasks = discardPeriodicTasks;\n/**\n * Flush any pending microtasks.\n *\n * @experimental\n */\nfunction flushMicrotasks() {\n    _getFakeAsyncZoneSpec().flushMicrotasks();\n}\nexports.flushMicrotasks = flushMicrotasks;\n//# sourceMappingURL=fake_async.js.map"]}