{"version":3,"sources":["validators.js"],"names":[],"mappings":"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","file":"validators-compiled.js","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { OpaqueToken } from '@angular/core';\nimport { ObservableWrapper } from './facade/async';\nimport { StringMapWrapper } from './facade/collection';\nimport { isBlank, isPresent, isPromise, isString } from './facade/lang';\nimport { PromiseWrapper } from './facade/promise';\n/**\n * Providers for validators to be used for {@link FormControl}s in a form.\n *\n * Provide this using `multi: true` to add validators.\n *\n * ### Example\n *\n * {@example core/forms/ts/ng_validators/ng_validators.ts region='ng_validators'}\n * @experimental\n */\nexport const NG_VALIDATORS = new OpaqueToken('NgValidators');\n/**\n * Providers for asynchronous validators to be used for {@link FormControl}s\n * in a form.\n *\n * Provide this using `multi: true` to add validators.\n *\n * See {@link NG_VALIDATORS} for more details.\n *\n * @experimental\n */\nexport const NG_ASYNC_VALIDATORS = \n/*@ts2dart_const*/ new OpaqueToken('NgAsyncValidators');\n/**\n * Provides a set of validators used by form controls.\n *\n * A validator is a function that processes a {@link FormControl} or collection of\n * controls and returns a map of errors. A null map means that validation has passed.\n *\n * ### Example\n *\n * ```typescript\n * var loginControl = new FormControl(\"\", Validators.required)\n * ```\n *\n * @experimental\n */\nexport class Validators {\n    /**\n     * Validator that requires controls to have a non-empty value.\n     */\n    static required(control) {\n        return isBlank(control.value) || (isString(control.value) && control.value == '') ?\n            { 'required': true } :\n            null;\n    }\n    /**\n     * Validator that requires controls to have a value of a minimum length.\n     */\n    static minLength(minLength) {\n        return (control) => {\n            if (isPresent(Validators.required(control)))\n                return null;\n            var v = control.value;\n            return v.length < minLength ?\n                { 'minlength': { 'requiredLength': minLength, 'actualLength': v.length } } :\n                null;\n        };\n    }\n    /**\n     * Validator that requires controls to have a value of a maximum length.\n     */\n    static maxLength(maxLength) {\n        return (control) => {\n            if (isPresent(Validators.required(control)))\n                return null;\n            var v = control.value;\n            return v.length > maxLength ?\n                { 'maxlength': { 'requiredLength': maxLength, 'actualLength': v.length } } :\n                null;\n        };\n    }\n    /**\n     * Validator that requires a control to match a regex to its value.\n     */\n    static pattern(pattern) {\n        return (control) => {\n            if (isPresent(Validators.required(control)))\n                return null;\n            let regex = new RegExp(`^${pattern}$`);\n            let v = control.value;\n            return regex.test(v) ? null :\n                { 'pattern': { 'requiredPattern': `^${pattern}$`, 'actualValue': v } };\n        };\n    }\n    /**\n     * No-op validator.\n     */\n    static nullValidator(c) { return null; }\n    /**\n     * Compose multiple validators into a single function that returns the union\n     * of the individual error maps.\n     */\n    static compose(validators) {\n        if (isBlank(validators))\n            return null;\n        var presentValidators = validators.filter(isPresent);\n        if (presentValidators.length == 0)\n            return null;\n        return function (control) {\n            return _mergeErrors(_executeValidators(control, presentValidators));\n        };\n    }\n    static composeAsync(validators) {\n        if (isBlank(validators))\n            return null;\n        var presentValidators = validators.filter(isPresent);\n        if (presentValidators.length == 0)\n            return null;\n        return function (control) {\n            let promises = _executeAsyncValidators(control, presentValidators).map(_convertToPromise);\n            return PromiseWrapper.all(promises).then(_mergeErrors);\n        };\n    }\n}\nfunction _convertToPromise(obj) {\n    return isPromise(obj) ? obj : ObservableWrapper.toPromise(obj);\n}\nfunction _executeValidators(control, validators) {\n    return validators.map(v => v(control));\n}\nfunction _executeAsyncValidators(control, validators) {\n    return validators.map(v => v(control));\n}\nfunction _mergeErrors(arrayOfErrors) {\n    var res = arrayOfErrors.reduce((res, errors) => {\n        return isPresent(errors) ? StringMapWrapper.merge(res, errors) : res;\n    }, {});\n    return StringMapWrapper.isEmpty(res) ? null : res;\n}\n//# sourceMappingURL=validators.js.map"]}